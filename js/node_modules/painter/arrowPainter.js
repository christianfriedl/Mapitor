/*
 * this will be able to paint an arrow and its subnodes on a paper
 */

"use strict";

var m_map = require('map.js');
var m_arrow = require('node/arrow.js');
var m_nodePainter = require('painter/nodePainter.js');
var m_painterFactory = require('painter/painterFactory.js');
var m_vector = require('vector.js');
var Raphael = require('raphael');

function ArrowPainter(/* m_arrow.Arrow */ p_node, /* Raphael */ p_paper) {
    if ( arguments.length > 0 ) {
        /* @DEVELOPMENT { */
            var LEN = 2; if ( arguments.length !== LEN ) { throw new Error('arguments length is ' + arguments.length + ', should be ' + LEN); }
            var PARAM = p_node; if ( !(PARAM instanceof m_arrow.Arrow) ) { throw new Error('type error: param p_map should be of type m_arrow.Arrow'); }
        /* @DEVELOPMENT } */
        m_nodePainter.NodePainter.call(this, p_node, p_paper);
    }
}

function arrowPainter(/* m_arrow.Arrow */ p_node, /* Raphael */ p_paper) {
    if ( arguments.length > 0 ) {
        /* @DEVELOPMENT { */
            var LEN = 2; if ( arguments.length !== LEN ) { throw new Error('arguments length is ' + arguments.length + ', should be ' + LEN); }
            var PARAM = p_node; if ( !(PARAM instanceof m_arrow.Arrow) ) { throw new Error('type error: param p_node should be of type m_arrow.Arrow'); }
        /* @DEVELOPMENT } */
        return new ArrowPainter(p_node, p_paper);
    } else {
        return new ArrowPainter();
    }
}


ArrowPainter.prototype = new m_nodePainter.NodePainter();
ArrowPainter.prototype.constructor = ArrowPainter;

ArrowPainter.prototype.paint = function() {
    if ( this._line !== undefined ) {
        this._line.remove();
        this._head.remove();
    }
    var x1, y1, x2, y2;
    var intersection = this._intersectionCoords(this._node.sourceNode());
    if ( intersection ) {
        x1 = intersection.x;
        y1 = intersection.y;
    } else {
        x1 = this._node.x1();
        y1 = this._node.y1();
    }
    var intersection = this._intersectionCoords(this._node.targetNode());
    if ( intersection ) {
        x2 = intersection.x;
        y2 = intersection.y;
    } else {
        x2 = this._node.x2();
        y2 = this._node.y2();
    }
    var tv = m_vector.vector(x2, y2);
    var v = this._node.vector();
    var headMiddle = tv.subtract(v.normalize().scale(10));
    var headLeft = headMiddle.add(v.normal().normalize().scale(3));
    var headRight = headMiddle.subtract(v.normal().normalize().scale(3));

    this._line = this._paper.line(x1, y1, x2, y2);
    this._head = this._paper.path('M' + headLeft.x + ' ' + headLeft.y + ' L' + headRight.x + ' ' + headRight.y + ' L' + tv.x + ' ' + tv.y + ' L' + headLeft.x + ' ' + headLeft.y + 'Z');
    this._line.attr({ 'stroke': '#000', 'fill': '#000' });
    this._head.attr({ 'stroke': '#000', 'fill': '#000' });
};


ArrowPainter.prototype._intersectWithBbox = function(bBox) {
        var int = null;
        var arrowPath = this._paper.pathForLine(this._node.x1(), this._node.y1(), this._node.x2(), this._node.y2());
        int = Raphael.pathIntersection(this._paper.pathForLine(bBox.x, bBox.y, bBox.x2, bBox.y), arrowPath);
        if ( int.length > 0 ) {
            return { x: int[0].x, y: int[0].y };
        }
        int = Raphael.pathIntersection(this._paper.pathForLine(bBox.x, bBox.y, bBox.x, bBox.y2), arrowPath);
        if ( int.length > 0 ) {
            return { x: int[0].x, y: int[0].y };
        }
        int = Raphael.pathIntersection(this._paper.pathForLine(bBox.x, bBox.y2, bBox.x2, bBox.y2), arrowPath);
        if ( int.length > 0 ) {
            return { x: int[0].x, y: int[0].y };
        }
        int = Raphael.pathIntersection(this._paper.pathForLine(bBox.x2, bBox.y, bBox.x2, bBox.y2), arrowPath);
        if ( int.length > 0 ) {
            return { x: int[0].x, y: int[0].y };
        }
        return false;
};

ArrowPainter.prototype._intersectionCoords = function(p_node) {
    var pf = m_painterFactory.painterFactory(this._node.map(), this._paper);
    var textNodePainter = pf.forObject(p_node);
    var bBox = textNodePainter.bBox();
    return this._intersectWithBbox(bBox);
};

ArrowPainter.prototype.deleteNodes = function() {
    this._line.remove();
    this._head.remove();
};

exports.ArrowPainter = ArrowPainter;
exports.arrowPainter = arrowPainter;
