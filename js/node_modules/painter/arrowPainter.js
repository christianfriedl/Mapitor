/*
 * Copyright (C) 2015 Christian Friedl <Mag.Christian.Friedl@gmail.com>
 *
 * This file is part of Mapitor.
 *
 * Mapitor is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses/>.
 */

/*
 * this will be able to paint an arrow and its subnodes on a paper
 */

"use strict";

var m_map = require('map.js');
var m_arrow = require('node/arrow.js');
var m_arrowWidget = require('widget/arrowWidget.js');
var m_nodePainter = require('painter/nodePainter.js');
var m_vector = require('vector.js');
var Raphael = require('raphael');

function ArrowPainter(/* m_nodeWidget.NodeWidget */ p_widget, /* Raphael */ p_paper, /* dom el */ p_div) {
    if ( arguments.length > 0 ) {
        /* @DEVELOPMENT { */
            var LEN = 3; if ( arguments.length !== LEN ) { throw new Error('arguments length is ' + arguments.length + ', should be ' + LEN); }
            var PARAM = p_widget; if ( !(PARAM instanceof m_arrowWidget.ArrowWidget) ) { throw new Error('type error: param p_widget should be of type m_arrowWidget.ArrowWidget'); }
        /* @DEVELOPMENT } */
        m_nodePainter.NodePainter.call(this, p_widget, p_paper, p_div);
    }
}

function arrowPainter(/* m_nodeWidget.NodeWidget */ p_widget, /* Raphael */ p_paper, /* dom el */ p_div) {
    if ( arguments.length > 0 ) {
        /* @DEVELOPMENT { */
            var LEN = 3; if ( arguments.length !== LEN ) { throw new Error('arguments length is ' + arguments.length + ', should be ' + LEN); }
            var PARAM = p_widget; if ( !(PARAM instanceof m_arrowWidget.ArrowWidget) ) { throw new Error('type error: param p_widget should be of type m_areaWidget.AreaWidget'); }
        /* @DEVELOPMENT } */
        return new ArrowPainter(p_widget, p_paper, p_div);
    } else {
        return new ArrowPainter();
    }
}


ArrowPainter.prototype = new m_nodePainter.NodePainter();
ArrowPainter.prototype.constructor = ArrowPainter;

ArrowPainter.prototype.paint = function() {
    console.log('arrowpainter paint widget', this._widget);
    if ( this._line !== undefined ) {
        this._line.remove();
        this._head.remove();
    }
    var x1, y1, x2, y2;
    var intersection = this._intersectionCoords(this._node.sourceNode());
    if ( intersection ) {
        x1 = intersection.x;
        y1 = intersection.y;
    } else {
        x1 = this._widget.x1();
        y1 = this._widget.y1();
    }
    var intersection = this._intersectionCoords(this._node.targetNode());
    if ( intersection ) {
        x2 = intersection.x;
        y2 = intersection.y;
    } else {
        x2 = this._widget.x2();
        y2 = this._widget.y2();
    }
    var tv = m_vector.vector(x2, y2);
    var v = this._widget.vector();
    var headMiddle = tv.subtract(v.normalize().scale(10));
    var headLeft = headMiddle.add(v.normal().normalize().scale(3));
    var headRight = headMiddle.subtract(v.normal().normalize().scale(3));

    this._line = this._paper.line(x1, y1, x2, y2);
    this._head = this._paper.path('M' + headLeft.x + ' ' + headLeft.y + ' L' + headRight.x + ' ' + headRight.y + ' L' + tv.x + ' ' + tv.y + ' L' + headLeft.x + ' ' + headLeft.y + 'Z');
    this._line.attr({ 'stroke': '#000', 'fill': '#000' });
    this._head.attr({ 'stroke': '#000', 'fill': '#000' });
};


ArrowPainter.prototype._intersectWithBbox = function(bBox) {
        var int = null;
        var arrowPath = this._paper.pathForLine(this._widget.x1(), this._widget.y1(), this._widget.x2(), this._widget.y2());
        int = Raphael.pathIntersection(this._paper.pathForLine(bBox.x, bBox.y, bBox.x2, bBox.y), arrowPath);
        if ( int.length > 0 ) {
            return { x: int[0].x, y: int[0].y };
        }
        int = Raphael.pathIntersection(this._paper.pathForLine(bBox.x, bBox.y, bBox.x, bBox.y2), arrowPath);
        if ( int.length > 0 ) {
            return { x: int[0].x, y: int[0].y };
        }
        int = Raphael.pathIntersection(this._paper.pathForLine(bBox.x, bBox.y2, bBox.x2, bBox.y2), arrowPath);
        if ( int.length > 0 ) {
            return { x: int[0].x, y: int[0].y };
        }
        int = Raphael.pathIntersection(this._paper.pathForLine(bBox.x2, bBox.y, bBox.x2, bBox.y2), arrowPath);
        if ( int.length > 0 ) {
            return { x: int[0].x, y: int[0].y };
        }
        return false;
};

ArrowPainter.prototype._intersectionCoords = function(p_node) {
    var textNodePainter = p_node.map().painter(p_node);
    var bBox = textNodePainter.bBox();
    return this._intersectWithBbox(bBox);
};

ArrowPainter.prototype.deleteNodes = function() {
    this._line.remove();
    this._head.remove();
};

exports.ArrowPainter = ArrowPainter;
exports.arrowPainter = arrowPainter;
