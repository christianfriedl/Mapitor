"use strict";
/* 
 * circular layouter for area
 */

var m_map = require('map.js');
var m_area = require('node/area.js');
var m_nodeLayouter = require('layouter/nodeLayouter.js');
var m_layouterFactory = require('layouter/layouterFactory.js');
var m_painterFactory = require('painter/painterFactory.js');
var m_textNode = require('node/textNode.js');
var m_trig = require('trigonometry.js');
var m_vector = require('vector.js');

function AreaLayouter(/* m_area.Area */ p_node) {
    if ( arguments.length > 0 ) {
        /* @DEVELOPMENT { */
            var LEN = 1; if ( arguments.length !== LEN ) { throw new Error('arguments length is ' + arguments.length + ', should be ' + LEN); }
            var PARAM = p_node; if ( !(PARAM instanceof m_area.Area) ) { throw new Error('type error: param p_map should be of type m_area.Area'); }
        /* @DEVELOPMENT } */
        m_nodeLayouter.NodeLayouter.call(this, p_node);
        this._seenNodes = [];
        this._seenArrowNodes = [];
    }
}

function areaLayouter(/* m_area.Area */ p_node) {
    if ( arguments.length > 0 ) {
        /* @DEVELOPMENT { */
            var LEN = 1; if ( arguments.length !== LEN ) { throw new Error('arguments length is ' + arguments.length + ', should be ' + LEN); }
            var PARAM = p_node; if ( !(PARAM instanceof m_area.Area) ) { throw new Error('type error: param p_node should be of type m_area.Area'); }
        /* @DEVELOPMENT } */
        return new AreaLayouter(p_node);
    } else {
        return new AreaLayouter();
    }
}


AreaLayouter.prototype = new m_nodeLayouter.NodeLayouter();
AreaLayouter.prototype.constructor = AreaLayouter;

AreaLayouter.prototype.layout = function() {
    var area = this._node;
    var lf = m_layouterFactory.layouterFactory(this._node.map());
    _(area.nodes()).each(function(n) {
        lf.forObject(n).layout();
    });

    // TODO currently we just assume that the centeredNode is in our area, which is clearly bad
    //

    var centeredNode = this._node.map().centeredNode();
    var centerCoords = m_vector.vector(this._node.x2(), this._node.y2()).add(m_vector.vector(this._node.x(), this._node.y())).scalarMultiply(0.5);
    centeredNode.moveTo(centerCoords.x, centerCoords.y);
    this._seenNodes = [ centeredNode ];
    this._layoutConnectedNodes(centeredNode, 90, 90, 0, 360);
    this._seenArrowNodes = [ centeredNode ];
    this._layoutArrows(centeredNode);
};


AreaLayouter.prototype._layoutConnectedNodes = function(/* m_node.Node */ p_node, /* number */ p_radius, /* number */ p_radiusDifference, /* number */ p_segmentStart, /* number */ p_segmentEnd) {
    var targetNodes = this.collectTargetNodes(p_node, this._seenNodes);
    var angle = p_segmentStart;
    var segment = p_segmentEnd - p_segmentStart;
    var angleDiff = Math.round(segment / targetNodes.length);
    _(targetNodes).each(function(node) {
        var coords = m_trig.coordsOnCircle(this._node.map().centeredNode().x(), this._node.map().centeredNode().y(), p_radius, angle);

        node.x(Math.round(coords.x));
        node.y(Math.round(coords.y));

        this._layoutConnectedNodes(node, p_radius + p_radiusDifference, p_radiusDifference, angle - angleDiff / 2, angle + angleDiff / 2);

        angle += angleDiff;
    }.bind(this));
};

AreaLayouter.prototype._layoutArrows = function(/* m_node.Node */ p_node) {
    var arrows = this.collectArrows(p_node, this._seenArrowNodes);
    _(arrows).each(function(a) {
        var layouter = m_layouterFactory.layouterFactory(this._node.map()).forObject(a);
        layouter.layout();
        var node = null;
        if ( a.sourceNode() === p_node ) {
            node = a.targetNode();
        } else {
            node = a.sourceNode();
       }
       this._layoutArrows(node);
    }.bind(this));
};

/*
 * TODO: extract to some static helper class; extract-away common code for nodes and arrows
 */
AreaLayouter.prototype.collectTargetNodes = function(/* m_node.Node */ p_node, /* array(m_node.Node) */ p_seenNodes) {
    var targetNodes = [];
    var arrows = p_node.arrows();
    _(arrows).each(function(a) {
        var node = null;
        if ( a.sourceNode() === p_node ) {
            node = a.targetNode();
        } else {
            node = a.sourceNode();
        }
        if ( !(_(p_seenNodes).contains(node)) ) {
            targetNodes.push(node);
            p_seenNodes.push(node);
        }
    }.bind(this));
    return targetNodes;
};

AreaLayouter.prototype.collectArrows = function(/* m_node.Node */ p_node, /* array(m_node.Node) */ p_seenNodes) {
    var targetArrows = [];
    var arrows = p_node.arrows();
    _(arrows).each(function(a) {
        var node = null;
        if ( a.sourceNode() === p_node ) {
            node = a.targetNode();
        } else {
            node = a.sourceNode();
       }
        if ( !(_(p_seenNodes).contains(node)) ) {
            targetArrows.push(a);
            p_seenNodes.push(node);
        }
    }.bind(this));
    return targetArrows;
};

exports.AreaLayouter = AreaLayouter;
exports.areaLayouter = areaLayouter;
