/*
 * Copyright (C) 2015 Christian Friedl <Mag.Christian.Friedl@gmail.com>
 *
 * This file is part of Mapitor.
 *
 * Mapitor is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses/>.
 */

"use strict";
/* 
 * circular layouter for area
 *
 * move-through-nodes strategy:
 *      - center the centeredNode
 *
 *      - layout all textnodes so they create their bboxes /// TODO: ??? really ??? -- alternatively, KNOW that there is an upper bound on the bbox
 *      - from centeredNode, recursively follow all arrows to layout all connected nodes
 *          - (collect seen arrows for recursion avoiding and caching)
 *      - for all as-of-yet unseen nodes
     *      - from this node, recursively follow all arrows to layout all connected nodes
 *          - (collect seen arrows for recursion avoiding and caching)
 *      - layout all arrows
 *
 * finally:
 *      - resize main area so nothing is negative or out of the area
 *      - move everything accordingly
 *
 *
 * layout strategy:
 *      - create concentric circles around centeredNode
 *      - each circle has this._circlePositionCounts[n] positions
 *      - (after 20 circles, the counts stay constant...)
 *      - circle 0 has 1 position
 *      - circle radius increases by 
 */

var m_map = require('map.js');
var m_area = require('node/area.js');
var m_nodeLayouter = require('layouter/nodeLayouter.js');
var m_layouterFactory = require('layouter/layouterFactory.js');
var m_textNode = require('node/textNode.js');
var m_trig = require('trigonometry.js');
var m_vector = require('vector.js');
var m_areaWidget = require('widget/areaWidget.js');
var m_arrowWidget = require('widget/arrowWidget.js');
var m_textNodeWidget = require('widget/textNodeWidget.js');

function AreaLayouter(/* m_areaWidget.AreaWidget */ p_widget) {
    if ( arguments.length > 0 ) {
        /* @DEVELOPMENT { */
            var LEN = 1; if ( arguments.length !== LEN ) { throw new Error('arguments length is ' + arguments.length + ', should be ' + LEN); }
            var PARAM = p_widget; if ( !(PARAM instanceof m_areaWidget.AreaWidget) ) { throw new Error('type error: param p_widget should be of type m_areaWidget.AreaWidget'); }
        /* @DEVELOPMENT } */
        m_nodeLayouter.NodeLayouter.call(this, p_widget);
        this._seenArrows = [];
        this._seenNodes = [];
        this._seenArrowNodes = [];
        this._radiusDifference = 120;
        this._circles = [];
    }
}

function areaLayouter(/* m_areaWidget.AreaWidget */ p_widget) {
    if ( arguments.length > 0 ) {
        /* @DEVELOPMENT { */
            var LEN = 1; if ( arguments.length !== LEN ) { throw new Error('arguments length is ' + arguments.length + ', should be ' + LEN); }
            var PARAM = p_widget; if ( !(PARAM instanceof m_areaWidget.AreaWidget) ) { throw new Error('type error: param p_widget should be of type m_areaWidget.AreaWidget'); }
        /* @DEVELOPMENT } */
        return new AreaLayouter(p_widget);
    } else {
        return new AreaLayouter();
    }
}


AreaLayouter.prototype = new m_nodeLayouter.NodeLayouter();
AreaLayouter.prototype.constructor = AreaLayouter;

AreaLayouter.prototype.layout = function() {
    var map = this._node.map();
    _(this._node.nodes()).each(function(n) {
        map.layouter(n).layout();
    });


    var centeredNode = this._node.map().centeredNode();

    var centerCoords = m_vector.vector(this._widget.x2(), this._widget.y2()).add(m_vector.vector(this._widget.x(), this._widget.y())).scalarMultiply(0.5);
    this._node.map().widget(centeredNode).moveTo(centerCoords.x, centerCoords.y);

    this._seenNodes = [ centeredNode ];

    var radius = this._layoutFromNode(centeredNode);

    var widget = undefined;

    do {
        widget = _(this._node.map().widgets()).find(function(w) {
            return ( (w instanceof m_textNodeWidget.TextNodeWidget) && !( _(this._seenNodes).contains(w.model())) ); // TODO possily optimize
        }.bind(this));
        if ( widget !== undefined ) {
            this._seenNodes.push(widget.model());
            radius = this._layoutFromNode(widget.model(), radius + this._radiusDifference, 0, 360);
        }
    } while ( widget !== undefined );
    
    
    this.reflow();
    this._layoutArrows();

};

AreaLayouter.prototype._layoutFromNode = function(/* m_node.Node */ p_node) {
    var targetNodes = this._collectTargetNodes(p_node, this._seenNodes);
    var centeredWidget = this._node.map().widget(this._node.map().centeredNode());
    var circlePos = this._findFirstFreePosition(); // { circleNr, pos }
    this._circles[circlePos.circleNr].takePosition(circlePos.pos);
    var radius = circlePos.circleNr * this._radiusDifference;
    var angle = 360 / this._circles[circlePos.circleNr].positionCount() * circlePos.pos; // should be an int, since all multiples of original count are integer divisors of 360
    var coords = m_trig.coordsOnCircle(centeredWidget.x(), centeredWidget.y(), radius, angle);
    var widget = this._node.map().widget(p_node);
    widget.x(Math.round(coords.x));
    widget.y(Math.round(coords.y));
    _(targetNodes).each(function(node) {
        this._layoutFromNode(node);
    }.bind(this));
};

/*
 * find the first possible free position on any circle
 * if none found on existing circles, create a new one
 */
/* { circleNr, pos } */ AreaLayouter.prototype._findFirstFreePosition = function() {
    for ( var i = 0; i < this._circles.length; ++i ) {
        var pos = this._circles[i].findFreePosition();
        if ( pos !== undefined ) {
            return { circleNr: i, pos: pos };
        }
    }
    var c = this._createCircle(i);
    var pos = c.findFreePosition();
    return { circleNr: i, pos: pos };
};

/* Circle */ AreaLayouter.prototype._createCircle = function(/* number */ num) {
    var c = new Circle(num);
    this._circles.push(c);
    return c;
};

AreaLayouter.prototype._layoutArrows = function() {
    _(_(this._node.map().widgets()).select(function(w) {
        return ( (w instanceof m_arrowWidget.ArrowWidget) && !(_(this._seenArrows).contains(w.model())) );
    }.bind(this))).each(function(w) {
        var layouter = this._node.map().layouter(w.model());
        layouter.layout();
        this._seenArrows.push(w.model());
    }.bind(this));
};

/*
 * TODO: extract to some static helper class; extract-away common code for nodes and arrows
 */
AreaLayouter.prototype._collectTargetNodes = function(/* m_node.Node */ p_node, /* array(m_node.Node) */ p_seenNodes) {
    var targetNodes = [];
    var arrows = p_node.arrows();
    _(arrows).each(function(a) {
        var node = null;
        if ( a.sourceNode() === p_node ) {
            node = a.targetNode();
        } else {
            node = a.sourceNode();
        }
        if ( !(_(p_seenNodes).contains(node)) ) {
            targetNodes.push(node);
            p_seenNodes.push(node);
        }
    }.bind(this));
    return targetNodes;
};

/*
 * circle has a number; the number determines how many open positions there are
 */
function Circle(/* number */ p_num) {
    this._num = p_num;
    this._positions = [];
}

Circle.prototype.constructor = Circle;

Circle.prototype.positionCount = function() {
    return Circle._positionCount(this._num);
};

Circle._positionCount = function(num) {
    return ( num > 0 ?
            ( num > 2 ?
              120 : (num * 6))
            : 1);
};


Circle.prototype.takePosition = function(pos) {
    this._positions.push(pos);
    this._positions = _(this._positions).sortBy( function(el) { return Number.parseInt(el); });
};

/*
 * given a pos on circle1, calculate its adjacent pos on circle2
 */
Circle.prototype.findPositionOnCircle = function(/* number */ circle1, /* number */ circle2, /* number */ pos) {
    return Math.round(pos / Circle._positionCount(circle1) * Circle._positionCount(circle2));
};

/*
 * from a given pos, search until we find a free pos
 * returns undefined if none found
 */
Circle.prototype.findFreePositionNextTo = function(pos) {
    var di = 0;
    var li = 0;
    var ri = 0;
    do {
        li = pos - di;
        ri = pos + di;
        if ( li >= 0 && this._positions.indexOf(li) === -1 ) {
            return li;
        } else if ( ri < this._positions.length - 1 && this._positions.indexOf(ri) === -1) {
            return ri;
        }
        ++di;
    } while (li >= 0 || ri < this._positions.length - 1);
    return undefined;
};

/*
 * find the free position with the most spare room around it
 * returns undefined if none found
 */
Circle.prototype.findFreePosition = function() {
    if ( this._positions.length === 0 ) {
        return Math.floor(this.positionCount() / 2);
    } else if ( this._positions.length === this.positionCount() ) {
        return undefined;
    } else if ( this._positions.length === 1 ) {
        if ( this._positions[0] > this.positionCount() / 2 ) {
            return Math.floor(this._positions[0] / 2);
        } else {
            return Math.floor(this._positions[0] + (this.positionCount() - this._positions[0]) / 2);
        }
    }
    var res = [];
    if ( this._positions[0] !== 0 ) {
        res[Math.floor(this._positions[0] / 2)] = this._positions[0];
    }
    for ( var i=0; i < this._positions.length - 1; ++i ) {
        var diff = this._positions[i + 1] - this._positions[i];
        var med = Math.floor((this._positions[i] + this._positions[i+1]) / 2);
        res[med] = diff;
    }
    if ( this._positions[this._positions.length - 1] !== this.positionCount() - 1 ) {
        res[this._positions[this._positions.length - 1] + Math.floor((this.positionCount() - this._positions[this._positions.length - 1]) / 2)] = this._positions[this._positions.length - 1];
    }
    if ( res.length > 0 ) {
        var max = 0;
        var maxInd = 0;
        for ( var i=0; i < res.length; ++i ) {
            if ( res[i] > max ) {
                max = res[i];
                maxInd = i;
            }
        }
        return maxInd;
    } else {
        return undefined;
    }
};

/*
 * TODO: does this really belong here?
 * it might make sense to optimize this by collecting the max* vars while laying out...
 * change the area and its contents so everything fits on the area
 */
AreaLayouter.prototype.reflow = function() {
    var minX = 0, minY = 0, maxX = 0, maxY = 0;

    _(this._node.nodes()).each(function(n) {
        if ( n instanceof m_textNode.TextNode ) { // we disregard arrows and subareas since the first don't have bboxes and the second don't exist yet
            var bbox = this._node.map().painter(n).bBox();
            minX = Math.min(bbox.x, minX);
            minY = Math.min(bbox.y, minY);
            maxX = Math.max(bbox.x2, maxX);
            maxY = Math.max(bbox.y2, maxY);
        }
    }.bind(this));
    var dX = Math.abs(Math.min(minX, 0));
    var dY = Math.abs(Math.min(minY, 0));

    if ( dX > 0 || dY > 0 ) {
        this._widget.moveAllBy(dX, dY);
    }


    var sizeX = Math.max(this._widget.width(), maxX - minX);
    var sizeY = Math.max(this._widget.height(), maxY - minY);

    this._widget.resize(sizeX, sizeY);
}; 

exports.AreaLayouter = AreaLayouter;
exports.areaLayouter = areaLayouter;
exports.Circle = Circle;
