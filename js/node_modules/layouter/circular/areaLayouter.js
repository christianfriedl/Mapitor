/*
 * Copyright (C) 2015 Christian Friedl <Mag.Christian.Friedl@gmail.com>
 *
 * This file is part of Mapitor.
 *
 * Mapitor is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses/>.
 */

"use strict";
/* 
 * circular layouter for area
 *
 * strategy:
 *      - center the centeredNode
 *
 *      - layout all textnodes so they create their bboxes /// TODO: ??? really ??? -- alternatively, KNOW that there is an upper bound on the bbox
 *      - from centeredNode, recursively follow all arrows to layout all connected nodes
 *          - create concentric circles to put the textnodes on
 *          - (collect seen arrows for recursion avoiding and caching)
 *      - for all as-of-yet unseen nodes
     *      - from this node, recursively follow all arrows to layout all connected nodes
 *          - create concentric circles to put the textnodes on
 *          - (collect seen arrows for recursion avoiding and caching)
 *      - layout all arrows
 *
 *      - resize main area so nothing is negative or out of the area
 *      - move everything accordingly
 */

var m_map = require('map.js');
var m_area = require('node/area.js');
var m_nodeLayouter = require('layouter/nodeLayouter.js');
var m_layouterFactory = require('layouter/layouterFactory.js');
var m_textNode = require('node/textNode.js');
var m_trig = require('trigonometry.js');
var m_vector = require('vector.js');
var m_areaWidget = require('widget/areaWidget.js');
var m_arrowWidget = require('widget/arrowWidget.js');
var m_textNodeWidget = require('widget/textNodeWidget.js');

function AreaLayouter(/* m_areaWidget.AreaWidget */ p_widget) {
    if ( arguments.length > 0 ) {
        /* @DEVELOPMENT { */
            var LEN = 1; if ( arguments.length !== LEN ) { throw new Error('arguments length is ' + arguments.length + ', should be ' + LEN); }
            var PARAM = p_widget; if ( !(PARAM instanceof m_areaWidget.AreaWidget) ) { throw new Error('type error: param p_widget should be of type m_areaWidget.AreaWidget'); }
        /* @DEVELOPMENT } */
        m_nodeLayouter.NodeLayouter.call(this, p_widget);
        this._seenArrows = [];
        this._seenNodes = [];
        this._seenArrowNodes = [];
        this._radiusDifference = 60;
    }
}

function areaLayouter(/* m_areaWidget.AreaWidget */ p_widget) {
    if ( arguments.length > 0 ) {
        /* @DEVELOPMENT { */
            var LEN = 1; if ( arguments.length !== LEN ) { throw new Error('arguments length is ' + arguments.length + ', should be ' + LEN); }
            var PARAM = p_widget; if ( !(PARAM instanceof m_areaWidget.AreaWidget) ) { throw new Error('type error: param p_widget should be of type m_areaWidget.AreaWidget'); }
        /* @DEVELOPMENT } */
        return new AreaLayouter(p_widget);
    } else {
        return new AreaLayouter();
    }
}


AreaLayouter.prototype = new m_nodeLayouter.NodeLayouter();
AreaLayouter.prototype.constructor = AreaLayouter;

AreaLayouter.prototype.layout = function() {
    var map = this._node.map();
    _(this._node.nodes()).each(function(n) {
        map.layouter(n).layout();
    });


    var centeredNode = this._node.map().centeredNode();

    var centerCoords = m_vector.vector(this._widget.x2(), this._widget.y2()).add(m_vector.vector(this._widget.x(), this._widget.y())).scalarMultiply(0.5);
    this._node.map().widget(centeredNode).moveTo(centerCoords.x, centerCoords.y);

    this._seenNodes = [ centeredNode ];

    var radius = this._layoutFromNode(centeredNode, this._radiusDifference, 0, 360);

    var widget = undefined;

    do {
        widget = _(this._node.map().widgets()).find(function(w) {
            return ( (w instanceof m_textNodeWidget.TextNodeWidget) && !( _(this._seenNodes).contains(w.model())) ); // TODO possily optimize
        }.bind(this));
        if ( widget !== undefined ) {
            this._seenNodes.push(widget.model());
            radius = this._layoutFromNode(widget.model(), radius + this._radiusDifference, 0, 360);
        }
    } while ( widget !== undefined );
    
    
    this._layoutArrows();
};

AreaLayouter.prototype._layoutFromNode = function(/* m_node.Node */ p_node, /* number */ p_radius, /* number */ p_angle, /* number */ p_segment) {
    console.log('_layoutFromNode', p_node);
    var maxRadius = p_radius;
    /*

- wenn radius > 0, dann lege p_node auf den ersten punkt und inkrementiere angle
- für alle connected nodes
    - lege sie auf kreis mit radius r und segmentStart + angleDiff
    - tue rekursiv dasselbe mit neuem segment und radius r + this._radiusDifference
- gib den aktuellen radius, segment, segmentStart, segmentEnd zurück
        


     */
    var angle = p_angle;
    var radius = p_radius;
    var segment = p_segment;

    var targetNodes = this._collectTargetNodes(p_node, this._seenNodes);
    var segmentStart = angle - segment / 2;
    var segmentEnd = angle + segment / 2;
    var angleDiff = Math.round(segment / targetNodes.length);
    maxRadius = radius;
    var centeredWidget = this._node.map().widget(this._node.map().centeredNode());
    var coords = m_trig.coordsOnCircle(centeredWidget.x(), centeredWidget.y(), radius, angle);
    var widget = this._node.map().widget(p_node);
    widget.x(Math.round(coords.x));
    widget.y(Math.round(coords.y));
    console.log('_layoutFromNode -> coords', coords);
    _(targetNodes).each(function(node) {
        maxRadius = this._layoutFromNode(node, radius + this._radiusDifference, angle, angleDiff);

        angle += angleDiff;
    }.bind(this));
    return maxRadius;
};

AreaLayouter.prototype._layoutArrows = function() {
    _(_(this._node.map().widgets()).select(function(w) {
        console.log('arealayouter select: ', (w instanceof m_arrowWidget.ArrowWidget), 'for', w);
        return ( (w instanceof m_arrowWidget.ArrowWidget) && !(_(this._seenArrows).contains(w.model())) );
    }.bind(this))).each(function(w) {
        var layouter = this._node.map().layouter(w.model());
        layouter.layout();
        console.log('arealayouter will layout arrow', w, 'now', w);
        this._seenArrows.push(w.model());
    }.bind(this));
};

/*
 * TODO: extract to some static helper class; extract-away common code for nodes and arrows
 */
AreaLayouter.prototype._collectTargetNodes = function(/* m_node.Node */ p_node, /* array(m_node.Node) */ p_seenNodes) {
    var targetNodes = [];
    var arrows = p_node.arrows();
    _(arrows).each(function(a) {
        var node = null;
        if ( a.sourceNode() === p_node ) {
            node = a.targetNode();
        } else {
            node = a.sourceNode();
        }
        if ( !(_(p_seenNodes).contains(node)) ) {
            targetNodes.push(node);
            p_seenNodes.push(node);
        }
    }.bind(this));
    return targetNodes;
};

AreaLayouter.prototype.collectArrows = function(/* m_node.Node */ p_node, /* array(m_node.Node) */ p_seenNodes) {
    var targetArrows = [];
    var arrows = p_node.arrows();
    _(arrows).each(function(a) {
        var node = null;
        if ( a.sourceNode() === p_node ) {
            node = a.targetNode();
        } else {
            node = a.sourceNode();
       }
        if ( !(_(p_seenNodes).contains(a)) ) {
            targetArrows.push(a);
            p_seenNodes.push(a);
        }
    }.bind(this));
    return targetArrows;
};

exports.AreaLayouter = AreaLayouter;
exports.areaLayouter = areaLayouter;
